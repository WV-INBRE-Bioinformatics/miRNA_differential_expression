addAbsFC <- function(DF, FCCOL = "foldChange") {
	    # Adds a new column 'absFoldChange', by converting 
	    # negative fold change to positive
	    # provide the name of fold change column

    DF$absFoldChange <- DF[, FCCOL]
    FC <- DF[, FCCOL]
    POS <- which(FC < 1)
    DF$absFoldChange[POS] <- 1/FC[POS]
    DF
}

addByColFactor <- function(DATA, colVec = 1) {
	    # Creates a new DF
	    # aggregrates the data based on factors in a specific
	    # column, provide the index of column containing factors

    if (length(colVec) == 1) {
        REFERENCE <- DATA[, colVec]
    } else {
        REFERENCE <- apply(DATA[, colVec], 1, function(x) gsub(" ", "", 
            paste(x, collapse = "_")))
    }
    DATA <- DATA[, sapply(colnames(DATA), function(x) class(DATA[, x])) == 
        "numeric"]
    URNAME <- unique(REFERENCE)
    NEW <- colSums(DATA[REFERENCE == URNAME[1], ])
    for (RN in URNAME[2:length(URNAME)]) {
        NEW <- rbind(NEW, colSums(DATA[REFERENCE == RN, ]))
    }
    rownames(NEW) <- URNAME
    NEW
}

addFC <- function(DF, logFCCOL = "log2FoldChange", LOG = 2) {
	    # Adds a new column 'foldchange',  using data from logfoldchange column, 
	    # provide the name of logfoldchange column and base of log

    DF$foldChange <- LOG^DF[, logFCCOL]
    DF
}

addMGI4GenCode <- function(DF, GENE_MGI) {
	    # Adds a new column 'mgi_symbol' having MGI codes, using GENE_MGI mappings
	    # provide ENSEMBL GENE to MGI mappings

    DF$mgi_symbol <- GENE_MGI[gsub("[.][0-9]+$", "", rownames(DF), perl = TRUE)]
    DF
}

addUpDown <- function(DF, log2FCCOL = "log2FoldChange") {
	    # Adds an a new column 'regulation'
	    # with 'Up', 'Down' and 'Unchanged' labels  
	    # denoting up, down and unchanged genes

    DF$regulation <- DF[, log2FCCOL]
    FC <- DF[, log2FCCOL]
    POS <- which(FC < 0)
    DF$regulation[POS] <- "Down"
    POS <- which(FC > 0)
    DF$regulation[POS] <- "Up"
    POS <- which(FC == 0)
    DF$regulation[POS] <- "Unchanged"
    DF
}

GETSUM <- function(X, CountsOrig) {
    # Function to aggregate base on a pattern in column names
    # See calling function to understand this

    NUM <- grep(X, colnames(CountsOrig))
    if (length(NUM) > 1) {
        SUMMATION <- rowSums(CountsOrig[, NUM])
    } else {
        SUMMATION <- CountsOrig[, NUM]
    }
    SUMMATION
}

Map2List <- function(DATA, KEY, VAL) {
	    # Converts multiple mappings to a list

    LIST <- list()
    IDS <- sort(unique(DATA[, KEY]))
    for (ID in 1:length(IDS)) {
        VALUES <- DATA[DATA[, KEY] == IDS[ID], ][, VAL]
        VALUES <- unique(VALUES[VALUES != ""])
        if (length(VALUES) >= 1) {
            LIST[[ID]] <- unique(VALUES[VALUES != ""])
        }
    }
    names(LIST) <- IDS
    LIST
}

MergeGeneNamesInExpMat <- function(GTF, refGTF, COUNTS) {
	    # This function merges the novel genes which are actually mapping to,
	    # valid references
	    # Provide the GTF of the data and GTF of references

    novel2ref <- NOVEL2REF(GTF, refGTF)
    novel2ref <- novel2ref[grep("^MST", names(novel2ref))]
    RefNovelDF <- as.data.frame(cbind(reference = novel2ref, novel = names(novel2ref)))
    REFNAMES <- as.vector(unique(RefNovelDF$reference[RefNovelDF$novel %in% 
        rownames(COUNTS)]))
    REFNAMES <- REFNAMES[grep("^ENS", REFNAMES)]
    DELETEPOS <- c()
    NEWNAMES <- as.data.frame(t(sapply(REFNAMES, function(NAME, DF, RNAMES, 
        DATA) {
        pos <- which(RNAMES %in% c(NAME, as.vector(DF[DF$reference == NAME, 
            ]$novel)))
        DELETEPOS <<- c(DELETEPOS, pos)
        colSums(DATA[pos, ])
    }, DF = RefNovelDF, RNAMES = rownames(COUNTS), DATA = COUNTS)))
    COUNTS <- COUNTS[-DELETEPOS, ]
    rbind(COUNTS, NEWNAMES)
}

NOVEL2REF <- function(GTF, refGTF) {
	    # This function provides a map between novel to reference names
	    # Provide the GTF for the data and reference GTF
	    # this function has specific code that only works with output generated by Stringtie
	    # and reference genes with Ensembl identifiers

    if (class(refGTF) != "data.frame") {
        refGTF <- READGTF(refGTF)
    }
    GTF <- read.delim(GTF, header = FALSE, sep = "\t", comment.char = "#")
    colnames(GTF) <- c("sl", "db", "type", "start", "end", "x", "strand", 
        "y", "name")
    GTF <- GTF[GTF$type == "transcript", ]
    NAMES <- as.vector(GTF[, c("name")])
    novelNAMES <- gsub("gene_id (.*?);.*$", "\\1", NAMES)
    refNAMES <- gsub(".*?ref_gene_id (.*?);.*$", "\\1", NAMES)
    refNAMES <- gsub("gene_id (MSTRG[^ ]+); .*?$", "\\1", refNAMES)
    GTF <- GTF[, c("start", "end")]
    GTF$novelgene <- novelNAMES
    GTF$refgene <- refNAMES
    novelNAMES <- sort(unique(novelNAMES))
    novel2ref <- c()
    for (GENE in novelNAMES) {
        len <- 0
        MAXREF <- ""
        REFGENES <- unique(GTF[GTF$novelgene == GENE, ]$refgene)
        REFGENES <- REFGENES[grep("^ENS", REFGENES)]
        if (length(REFGENES) > 0) {
            for (REFGENE in REFGENES) {
                RECORD <- refGTF[REFGENE, ]
                LEN <- RECORD$end - RECORD$start
                if (LEN > len) {
                  len <- LEN
                  MAXREF <- REFGENE
                }
            }
            novel2ref <- c(novel2ref, MAXREF)
        } else {
            novel2ref <- c(novel2ref, GENE)
        }
    }
    names(novel2ref) <- novelNAMES
    novel2ref
}

PC <- function(VAR = "Progress", N = 0) {
		# Writes comment to stdout with correct indentation
	cat(paste(paste(replicate(N, "    "), collapse = ""), VAR, "    ", 
            "\n", sep = ""))
}

READGTF <- function(refGTF) {
	    # Reads a GTF file and returns a data frame with start and end values 
	    # row names as gene names
	    # provide the GTF file name 'refGTF'

    refGTF <- read.delim(refGTF, header = FALSE, sep = "\t", comment.char = "#")
    colnames(refGTF) <- c("sl", "db", "type", "start", "end", "x", "strand", 
        "y", "name")
    refGTF <- refGTF[refGTF$type == "gene", ]
    NAMES <- refGTF[, c("name")]
    NAMES <- gsub("gene_id (.*?);.*$", "\\1", NAMES)
    refGTF <- refGTF[, c("start", "end")]
    rownames(refGTF) <- NAMES
    refGTF
}

replaceDFColNAs <- function(DF, COLNAME, REPLACE) {
	    # This function replaces NAs in column 'COLNAME' with given replacement 'REPLACE'

    DF[, COLNAME][which(is.na(DF[, COLNAME]))] <- REPLACE
    DF
}

ReplaceEmptyMappings <- function(DF, SOURCE, TARGET) {
	    # This function replaces empty targets in the map with 
	    # Source identifiers
	    # Provide data frame and variables SOURCE and TARGET 
	    # whicha are column names of the data frame

    POS <- which(DF[, TARGET] == "")
    DF[, TARGET][POS] <- DF[, SOURCE][POS]
    POS <- which(DF[, TARGET] == "NA")
    DF[, TARGET][POS] <- DF[, SOURCE][POS]
    POS <- which(is.na(DF[, TARGET]))
    DF[, TARGET][POS] <- DF[, SOURCE][POS]
    DF
}

takeFirstCommonRow <- function(DATA, colVec = 1) {
	    # This function takes data from first common row, if there are multiple rows with same name
	    # Names of the data can be given by specifiying the column name/number or column names/numbers
	    # if multiple columns need to combined for concatenated names

    if (length(colVec) == 1) {
        REFERENCE <- DATA[, colVec]
    } else {
        REFERENCE <- apply(DATA[, colVec], 1, function(x) gsub(" ", "", 
            paste(x, collapse = "_")))
    }
    URNAME <- unique(REFERENCE)
    NEW <- DATA[REFERENCE == URNAME[1], ][1, ]
    for (RN in URNAME[2:length(URNAME)]) {
        NEW <- rbind(NEW, DATA[REFERENCE == RN, ][1, ])
    }
    NEW
}

pasteC<-function(VECTOR, SEP=",")
{
		# This function takes a vector and joins the elements with the SEP string that is specified
		# If there is SEP string at the beginning of the resultant string it is removed
	if(length(VECTOR) > 0)
	{
		RETURN<-gsub(paste("^", SEP, sep=""), "", paste(VECTOR, collapse = SEP))
	} else {
		RETURN<-""
	}
	RETURN
}


GETDATA<-function(TYPE, ENTRY, LIST, SOURCE, TARGET, MAX, DE)
{
		# This function outputs the up, down regulated targets,  for both significant and non-significant cases
		# Needs the results LIST (which is multimir results object) obtained from the main miRNA_mRNA analysis script
		# Needs 'DE' which is the DESeq results object for targets 
		# SOURCE represents the source id
		# TARGET represents the target id
		# ENTRY is the name of this miRNA or mRNA query
		# TYPE can be either validated or predicted, for validated or predicted targets in the multimir db
		# MAX represents the number of targets to list in output table

        FREQ=c('ALL'=0, 'UP'=0, 'DOWN'=0, 'sigUP'=0, 'sigDOWN'=0, 'nsigUP'=0, 'nsigDOWN'=0)
        FREQ=c( 'sigUP'=0, 'sigDOWN'=0, 'nsigUP'=0, 'nsigDOWN'=0)
        sigUP=0;
        sigDOWN=0;
        nsigUP=0;
        nsigDOWN=0;

        # Get the data table
        DATA<-as.data.frame(LIST[[TYPE]])

        # Get the list of targets
        RESULT<-sort(unique(as.vector(DATA[DATA[,SOURCE] == ENTRY,][,TARGET])))
		

        # Initialize
        SIGNIFICANT_up<-""
        SIGNIFICANT_down<-""
        NON_SIGNIFICANT_up<-""
        NON_SIGNIFICANT_down<-""

        # Proceed only if there are any targets
        if(length(RESULT) > 0) {

                #FREQ['ALL']=length(RESULT)
                #Get only the list of targets that are present in the mRNA/miRNA DE tables
                DE<-subset(DE, rownames(DE) %in% RESULT)

				# Consider all below ALPHA=1 genes
                ALL_up <- SigGenes(DE, ALPHA=1, WHICH="up", ORDERBY="log2FoldChange")
                ALL_down <- SigGenes(DE, ALPHA=1, WHICH="down", ORDERBY="log2FoldChange")

                if(length(ALL_up) > 0) {

                        #FREQ['UP']=length(ALL_up)
                        SIG_up<-SigGenes(DE, ALPHA=0.1, WHICH="up", ORDERBY="log2FoldChange")

                        if(length(SIG_up) > 0) {
                                #FREQ['sigUP']=length(SIG_up)
                                sigUP=length(SIG_up)
                                NON_SIGNIFICANT_up<-ALL_up[! ALL_up %in% SIG_up]
                                #FREQ['nsigUP']=length(NON_SIGNIFICANT_up)
                                nsigUP=length(NON_SIGNIFICANT_up)
				if(length(nsigUP) > 0) {
                                	NON_SIGNIFICANT_up<-pasteC(NON_SIGNIFICANT_up[1:min(MAX,length(NON_SIGNIFICANT_up))], SEP=";")
				} else {
                                	NON_SIGNIFICANT_up<-""
				}
                                SIGNIFICANT_up<-pasteC(SIG_up, SEP=";")
                        } else {
                                NON_SIGNIFICANT_up<-pasteC(ALL_up[1:min(MAX,length(ALL_up))], SEP=";")
                                SIGNIFICANT_up<-""
                        }
                } else {
                                SIGNIFICANT_up<-""
                                NON_SIGNIFICANT_up<-""
                }

                if(length(ALL_down) > 0) {

                        #FREQ['DOWN']=length(ALL_down)
                        SIG_down<-SigGenes(DE, ALPHA=0.1, WHICH="down", ORDERBY="log2FoldChange")

                        if(length(SIG_down) > 0) {
                                #FREQ['sigDOWN']=length(SIG_down)
                                sigDOWN=length(SIG_down)
                                NON_SIGNIFICANT_down<-ALL_down[! ALL_down %in% SIG_down]
                                #FREQ['nsigDOWN']=length(NON_SIGNIFICANT_down)

                                nsigDOWN=length(NON_SIGNIFICANT_down)
				if(length(nsigDOWN) > 0) {
                                	NON_SIGNIFICANT_down<-pasteC(NON_SIGNIFICANT_down[1:min(MAX,length(NON_SIGNIFICANT_down))], SEP=";")
				} else {
                                	NON_SIGNIFICANT_down<-""
				}
                                SIGNIFICANT_down<-pasteC(SIG_down, SEP=";")
                        } else {
                                nsigDOWN=length(ALL_down)
                                NON_SIGNIFICANT_down<-pasteC(ALL_down[1:min(MAX,length(ALL_down))], SEP=";")
                                SIGNIFICANT_down<-""
                        }
                } else {
                        SIGNIFICANT_down<-""
                        NON_SIGNIFICANT_down<-""
                }
        }

		# Need to identify why some cases have NA, when it needs to be an empty string. Temporary solution here
		if(SIGNIFICANT_up == "NA") { SIGNIFICANT_up<-"" }
		if(NON_SIGNIFICANT_up == "NA") { NON_SIGNIFICANT_up<-"" }
		if(SIGNIFICANT_down == "NA") { SIGNIFICANT_down<-"" }
		if(NON_SIGNIFICANT_down == "NA") { NON_SIGNIFICANT_down<-"" }
		if(is.na(SIGNIFICANT_up)) { SIGNIFICANT_up<-"" }
		if(is.na(NON_SIGNIFICANT_up)) { NON_SIGNIFICANT_up<-"" }
		if(is.na(SIGNIFICANT_down)) { SIGNIFICANT_down<-"" }
		if(is.na(NON_SIGNIFICANT_down)) { NON_SIGNIFICANT_down<-"" }

                # collect and return the list
		#print(paste(ENTRY, TYPE, "sUP = ",  SIGNIFICANT_up, "sDOWN = ", SIGNIFICANT_down, "nUP = ", NON_SIGNIFICANT_up, "nDOWN = ", NON_SIGNIFICANT_down, "fUP = ", sigUP, "fDOWN = ", sigDOWN, "nfUP = ", nsigUP, "nfDOWN = ", nsigDOWN))

		# For total frequency do this
		#TOTAL=sigUP+sigDOWN+nsigUP+nsigDOWN;
                #list('nTARGETS'=c(TOTAL), 'GENES'=c(SIGNIFICANT_up, SIGNIFICANT_down,NON_SIGNIFICANT_up, NON_SIGNIFICANT_down), 'FREQ'= c(sigUP, sigDOWN, nsigUP, nsigDOWN))

		# Now print all targets not found in DE list
		RESULT<-RESULT[! RESULT %in% unlist(strsplit(paste(c(SIGNIFICANT_up, SIGNIFICANT_down,NON_SIGNIFICANT_up, NON_SIGNIFICANT_down), collapse=","), ";"))]
		nRESULT<-length(RESULT)

		RESULT<-pasteC(RESULT[1:min(MAX,length(RESULT))], SEP=";")

		if(RESULT == "NA") { RESULT <-"" }
		if(is.na(RESULT)) { RESULT <-"" }
		
		
		#Convert ensembl to symbols
		if(RESULT != "") {
			RESULT<-ensembl2mgi(RESULT)
		}
		if(SIGNIFICANT_up != "") {
			SIGNIFICANT_up<-ensembl2mgi(SIGNIFICANT_up)
		}
		if(SIGNIFICANT_down != "") {
			SIGNIFICANT_down<-ensembl2mgi(SIGNIFICANT_down)
		}
		if(NON_SIGNIFICANT_up != "") {
			NON_SIGNIFICANT_up<-ensembl2mgi(NON_SIGNIFICANT_up)
		}
		if(NON_SIGNIFICANT_down != "") {
			NON_SIGNIFICANT_down<-ensembl2mgi(NON_SIGNIFICANT_down)
		}
		

 	list('GENES'=c(SIGNIFICANT_up, SIGNIFICANT_down,NON_SIGNIFICANT_up, NON_SIGNIFICANT_down, RESULT), 'FREQ'= c(sigUP, sigDOWN, nsigUP, nsigDOWN, nRESULT))

 	#list('GENES'=c(SIGNIFICANT_up, SIGNIFICANT_down,NON_SIGNIFICANT_up, NON_SIGNIFICANT_down), 'FREQ'= c(sigUP, sigDOWN, nsigUP, nsigDOWN))
}


ensembl2mgi<-function(DATA)
{
	
		# Convert ENSEMBL IDs to symbols
		# DATA is a single string of ensembl ids seperated by commas
		# GENE_MGI is a character vector with names as ensembl ids and values as gene symbols
		# GENE_MGI and MAX_TARGETS are defined in the main script
		DATA<- GENE_MGI[gsub("[.][0-9]+$", "", unlist(strsplit(DATA, ";")), perl = TRUE)]
		DATA<-pasteC(DATA[1:min(MAX_TARGETS,length(DATA))], SEP=";")
		DATA	
}

GETDATA_NO_TARGET_DE<-function(TYPE, ENTRY, LIST, SOURCE, TARGET, MAX)
{
		# This function is similar to the GETDATA function, except that the DESeq results for targets is not supplied
		# This function obtains the targets
		# Needs the results LIST (which is multimir results object) obtained from the main miRNA_mRNA analysis script
		# SOURCE represents the source id
		# TARGET represents the target id
		# ENTRY is the name of this miRNA or mRNA query
		# TYPE can be either validated or predicted, for validated or predicted targets in the multimir db
		# MAX represents the number of targets to list in output table
        # Get the data table
        DATA<-as.data.frame(LIST[[TYPE]])

        # Get the list of targets
        RESULT<-sort(unique(as.vector(DATA[DATA[,SOURCE] == ENTRY,][,TARGET])))
	LENGTH<-length(RESULT)
	RESULT<-pasteC(RESULT[1:min(MAX,LENGTH)])

        # collect and return the list
        #list('GENES'=c(SIGNIFICANT_up, SIGNIFICANT_down,NON_SIGNIFICANT_up, NON_SIGNIFICANT_down), 'FREQ'= FREQ)
        list('GENES'= c(RESULT), 'FREQ'= c(LENGTH))
}


EXTRACT_TARGETS<-function(ENTRY, LIST, SOURCE, TARGET, MAX, DE)
{
		# This is just a wrapper for doing the following
		# useful in the main miRNA_mRNA analysis script
	sapply(c("validated", "predicted"), function(TYPE) { unlist(GETDATA(TYPE, ENTRY, LIST, SOURCE, TARGET, MAX, DE))})
}


EXTRACT_TARGETS_NO_TARGET_DE<-function(ENTRY, LIST, SOURCE, TARGET, MAX, DE)
{
		# This is just a wrapper for doing the following
		# useful in the main miRNA_mRNA analysis script
	sapply(c("validated", "predicted"), function(TYPE) { unlist(GETDATA_NO_TARGET_DE(TYPE, ENTRY, LIST, SOURCE, TARGET, MAX))})
}


WRITE_SIG_TABLES<-function(DF, NAME, PVAL="padj", ALPHA=0.05, FC="absFoldChange")
{
		# Wrapper to write DE significance tables for a specified p-value cutoff
		# After all columns of the tables are finalized, use this just to sort and write to file
	X<-DF
        X<-DF[DF[,PVAL]<ALPHA,]
	X<-X[order(X[,FC], decreasing=TRUE),]
	write.table(X, file=paste(NAME, ALPHA, "csv", sep="."), quote=FALSE, sep="\t")
}

SigGenes<-function(DF, PADJ="padj", ALPHA=0.05, WHICH="all", log2FCCOL="log2FoldChange", ORDERBY="padj") {
		# Filters significant genes according to given criteria
        #if(class(DF)[1] != "DESeqResults") 
        #{
        #        print("The input is not a DESeqResults object. Exiting!")
        #        return(1)
        #}
        DF<-DF[DF[,PADJ] < ALPHA, ]

        if(WHICH == "up") {
                DF<-DF[DF[,log2FCCOL] > 0,]
        } else if(WHICH == "down") {
                DF<-DF[DF[,log2FCCOL] < 0,]
        } 
        #rownames(DF[DF[,PADJ] < ALPHA, ])
        if(ORDERBY == "log2FoldChange") {
                rownames(DF[order(abs(DF[,ORDERBY]), decreasing=TRUE),])
        } else if(ORDERBY == "padj") {
                rownames(DF[order(DF[,ORDERBY]),])
        }
}

ReadJimsDeseqMRNAresults<-function(TABLE)
{
	# Use this function to read the mRNA DESeq2 results table (Tables from Jim Denvir, MU)

	RNAdata<-read.table(TABLE, header=TRUE, row.names=1, sep=",")

	RNAdata<-RNAdata[,c("baseMean", "log2FoldChange", "lfcSE", "stat", "pvalue", "padj", "effect", "symbol")]

	EFFECT<-t(sapply(as.vector(RNAdata[,"effect"]),  function(X) {unlist(strsplit(X, " ", perl=TRUE))}))

	RNAdata$foldchange<-as.numeric(as.vector(EFFECT[,1]))

	RNAdata$regulation<-as.vector(EFFECT[,2])  

	RNAdata$absFoldChange<-abs(RNAdata$foldchange)

	RNAdata<-RNAdata[, -which(colnames(RNAdata) == "effect" )]
	RNAdata
}


# Sridhar A Malkaram (smalkaram@wvstateu.edu)
# Last modified on: 01/30/2018
